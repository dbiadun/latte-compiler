-- automatically generated by BNF Converter
module Main where

import AbsLatte
import Control.Monad (when)
import ErrM
import LLVMGenerator
import LexLatte
import ParLatte
import PrintLatte
import SemanticAnalysis (check)
import System.Environment (getArgs, getProgName)
import System.Exit (exitFailure, exitSuccess)
import System.FilePath (replaceExtension)
import System.IO (hGetContents, hPutStrLn, stderr, stdin)
import System.Process (callCommand)

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: Show a => Verbosity -> ParseFun (Program a) -> FilePath -> IO ()
runFile v p f = readFile f >>= run v p f

run :: Show a => Verbosity -> ParseFun (Program a) -> FilePath -> String -> IO ()
run v p f s =
  let ts = myLLexer s
   in case p ts of
        Bad s -> do
          hPutStrLn stderr "ERROR"
          putStrLn "\nParse              Failed...\n"
          putStrV v "Tokens:"
          putStrV v $ show ts
          putStrLn s
          exitFailure
        Ok tree -> do
          check tree

          let llvmInstructions = genLLVM tree
          writeFile (replaceExtension f "ll") llvmInstructions
--          callCommand $ "llvm-as -o " ++ replaceExtension f "bc" ++ " " ++ replaceExtension f "ll"

          exitSuccess

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree =
  do
    putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
    putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $
    unlines
      [ "usage: Call with one of the following argument combinations:",
        "  --help          Display this help message.",
        "  (no arguments)  Parse stdin verbosely.",
        "  (files)         Parse content of files verbosely.",
        "  -s (files)      Silent mode. Parse content of files silently."
      ]
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    [] -> getContents >>= run 2 pProgram "output.ins"
    "-s" : fs -> mapM_ (runFile 0 pProgram) fs
    fs -> mapM_ (runFile 2 pProgram) fs
