module SemanticAnalysis where

-- Haskell module generated by the BNF converter

import AbsLatte as Grammar
import Control.Monad (void)
import Control.Monad.Except
import Control.Monad.State
import qualified Data.Map as Map
import Data.Maybe
import qualified Data.Set as Set
import ErrM
import System.Exit (exitFailure)
import System.IO

-------------------------------------------------------------------------------

type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

checkIdent :: Ident -> Result
checkIdent x = case x of
  Ident string -> failure x

checkProgram :: Show a => Program a -> Result
checkProgram x = case x of
  Program _ topdefs -> failure x

checkTopDef :: Show a => TopDef a -> Result
checkTopDef x = case x of
  FnDef _ type_ ident args block -> failure x

checkArg :: Show a => Arg a -> Result
checkArg x = case x of
  Arg _ type_ ident -> failure x

checkBlock :: Show a => Block a -> Result
checkBlock x = case x of
  Block _ stmts -> failure x

checkStmt :: Show a => Stmt a -> Result
checkStmt x = case x of
  Empty _ -> failure x
  BStmt _ block -> failure x
  Decl _ type_ items -> failure x
  Ass _ ident expr -> failure x
  Incr _ ident -> failure x
  Decr _ ident -> failure x
  Ret _ expr -> failure x
  VRet _ -> failure x
  Cond _ expr stmt -> failure x
  CondElse _ expr stmt1 stmt2 -> failure x
  While _ expr stmt -> failure x
  SExp _ expr -> failure x

checkItem :: Show a => Item a -> Result
checkItem x = case x of
  NoInit _ ident -> failure x
  Init _ ident expr -> failure x

checkType :: Show a => Type a -> Result
checkType x = case x of
  Int _ -> failure x
  Str _ -> failure x
  Bool _ -> failure x
  Void _ -> failure x
  Fun _ type_ types -> failure x

checkExpr :: Show a => Expr a -> Result
checkExpr x = case x of
  EVar _ ident -> failure x
  ELitInt _ integer -> failure x
  ELitTrue _ -> failure x
  ELitFalse _ -> failure x
  EApp _ ident exprs -> failure x
  EString _ string -> failure x
  Neg _ expr -> failure x
  Not _ expr -> failure x
  EMul _ expr1 mulop expr2 -> failure x
  EAdd _ expr1 addop expr2 -> failure x
  ERel _ expr1 relop expr2 -> failure x
  EAnd _ expr1 expr2 -> failure x
  EOr _ expr1 expr2 -> failure x

checkAddOp :: Show a => AddOp a -> Result
checkAddOp x = case x of
  Plus _ -> failure x
  Minus _ -> failure x

checkMulOp :: Show a => MulOp a -> Result
checkMulOp x = case x of
  Times _ -> failure x
  Div _ -> failure x
  Mod _ -> failure x

checkRelOp :: Show a => RelOp a -> Result
checkRelOp x = case x of
  LTH _ -> failure x
  LE _ -> failure x
  GTH _ -> failure x
  GE _ -> failure x
  EQU _ -> failure x
  NE _ -> failure x
